<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Enoch-Blog</title>
  
  <subtitle>叫啥好呢叫啥好呢</subtitle>
  <link href="/blog.github.io/atom.xml" rel="self"/>
  
  <link href="https://github.com/Enochxyn/blog.github.io.git/"/>
  <updated>2020-06-15T06:24:21.338Z</updated>
  <id>https://github.com/Enochxyn/blog.github.io.git/</id>
  
  <author>
    <name>Enoch Xu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python面试题</title>
    <link href="https://github.com/Enochxyn/blog.github.io.git/2020/06/15/Python%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://github.com/Enochxyn/blog.github.io.git/2020/06/15/Python%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-06-15T06:07:01.000Z</published>
    <updated>2020-06-15T06:24:21.338Z</updated>
    
    <content type="html"><![CDATA[<p>申明：这里整理的面试题题目主要来源于网络搜集，答案根据自己实践整理修改。</p><h1 id="1-简述解释型语言和编译型语言区别"><a href="#1-简述解释型语言和编译型语言区别" class="headerlink" title="1. 简述解释型语言和编译型语言区别"></a>1. 简述解释型语言和编译型语言区别</h1><p><strong>解释型：</strong><br>在运行的时候将代码翻译成目标机器代码进行执行，每次执行都会进行翻译。现代解释型语言基本都会将源码翻译成中间字节码，然后在运行的时候将中间字节码翻译成目标机器代码进行执行。<br><strong>编译型：</strong><br>先编译成机器语言再执行，编译和执行是分开的。每次执行的时候不需要再编译。</p><h1 id="2-Python解释器种类以及特点？"><a href="#2-Python解释器种类以及特点？" class="headerlink" title="2. Python解释器种类以及特点？"></a>2. Python解释器种类以及特点？</h1><ul><li>CPython<br>c语言开发的 使用最广的解释器，默认使用的解释器。</li><li>JPython<br>Java编写的，运行在Java上的解释器 直接把python代码编译成Java字节码执行。</li><li>IPython<br>IPython 是一个 python 的交互式 shell，比默认的python shell 好用得多，支持变量自动补全，自动缩进，支持 bash shell 命令，内置了许多很有用的功能和函数。</li><li>PyPy<br>Python编写的。目标是执行效率 采用JIT（Just In Time：即时编译技术，简单的例子就是对于循环里的语句不会每次循环的时候都重新翻译，而是一次性翻译然后存起来，等到执行到的时候就将已经翻译过来的机器码直接拿来使用）技术 对python代码进行动态编译，提高执行效率。但是由于是用Python编写，所以在启动的时候会比CPython解释器启动慢。</li><li>IronPython<br>.net编写的，运行在微软 .NET 平台上的解释器，把python编译成. NET 的字节码。</li></ul><h1 id="3-请至少列举5个-PEP8-规范（越多越好）。"><a href="#3-请至少列举5个-PEP8-规范（越多越好）。" class="headerlink" title="3. 请至少列举5个 PEP8 规范（越多越好）。"></a>3. 请至少列举5个 PEP8 规范（越多越好）。</h1><ul><li>每一级缩进使用4个空格。</li><li>所有行限制的最大字符数为79。</li><li>顶层函数和类的定义，前后用两个空行隔开。</li><li>类里的方法定义用一个空行隔开。</li><li>import通常在分开的行，例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">推荐: import os</span><br><span class="line"></span><br><span class="line">    import sys</span><br><span class="line"></span><br><span class="line">不推荐:  import sys, os</span><br></pre></td></tr></table></figure></li></ul><h1 id="4-完成以下的进制转换"><a href="#4-完成以下的进制转换" class="headerlink" title="4. 完成以下的进制转换"></a>4. 完成以下的进制转换</h1><h3 id="4-1-从10进制转成2、8、16进制"><a href="#4-1-从10进制转成2、8、16进制" class="headerlink" title="4.1 从10进制转成2、8、16进制"></a>4.1 从10进制转成2、8、16进制</h3><p>设v = 18 </p><ul><li>10进制转2进制<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(bin(v))</span><br></pre></td></tr></table></figure></li><li>10进制转8进制<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(oct(v))</span><br></pre></td></tr></table></figure></li><li>10进制转16进制<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(hex(v))</span><br></pre></td></tr></table></figure><h3 id="4-2-从2、8、16进制转10进制"><a href="#4-2-从2、8、16进制转10进制" class="headerlink" title="4.2 从2、8、16进制转10进制"></a>4.2 从2、8、16进制转10进制</h3></li><li>2进制转10进制：v = “0b1111011”<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(int(v, 2))</span><br></pre></td></tr></table></figure></li><li>8进制转10进制：v = “011”<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(int(v, 8))</span><br></pre></td></tr></table></figure></li><li>16进制转10进制：v = “0x1c”<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(int(v, 16))</span><br></pre></td></tr></table></figure></li></ul><h1 id="5-请编写一个函数实现将IP地址转换成一个整数。"><a href="#5-请编写一个函数实现将IP地址转换成一个整数。" class="headerlink" title="5. 请编写一个函数实现将IP地址转换成一个整数。"></a>5. 请编写一个函数实现将IP地址转换成一个整数。</h1><p>如 10.3.9.12 转换规则为：<br>10 -&gt; 00001010<br>3 -&gt; 00000011<br>9 -&gt; 00001001<br>12 -&gt; 00001100<br>再将以上二进制拼接起来计算十进制结果：00001010 00000011 00001001 00001100 = ？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def ip_transfer(ip):</span><br><span class="line">    ip_items &#x3D; ip.split(&#39;.&#39;)</span><br><span class="line">    # 10进制转2进制 且 拼接</span><br><span class="line">    s &#x3D; &#39;&#39;.join(bin(int(item))[2::] for item in ip_items)</span><br><span class="line">    return int(s, 2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    print(ip_transfer(&quot;10.1.15.110&quot;))</span><br></pre></td></tr></table></figure><h1 id="6-python递归的最大层数"><a href="#6-python递归的最大层数" class="headerlink" title="6. python递归的最大层数"></a>6. python递归的最大层数</h1><p>由于python为了防止无限递归，设计了递归限制是998。<br>可以自行设置递归最大限制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.setrecursionlimit(100000)</span><br></pre></td></tr></table></figure><h1 id="7-ascii、unicode、utf-8、gbk区别"><a href="#7-ascii、unicode、utf-8、gbk区别" class="headerlink" title="7. ascii、unicode、utf-8、gbk区别"></a>7. ascii、unicode、utf-8、gbk区别</h1><ul><li>Ascii<br>美国信息互换标准代码</li><li>Gbk<br>在gb2312的基础上增加了汉字，而gb2312在ascii的基础上增加了汉字</li><li>Unicode<br>是字符集</li><li>Utf-8<br>是编码规则，是对unicode的一种实现，可以将unicode码对应再编码成1-4字节大小。</li></ul><h1 id="8-字节码和机器码的区别"><a href="#8-字节码和机器码的区别" class="headerlink" title="8. 字节码和机器码的区别"></a>8. 字节码和机器码的区别</h1><ul><li>字节码<br>字节码是一种中间状态(介于源代码和目标机器代码之间)的二进制代码。需要转译成目标机器代码。</li><li>机器码<br>计算机可以直接执行的代码。</li></ul><h1 id="9-列举-Python2和Python3的区别"><a href="#9-列举-Python2和Python3的区别" class="headerlink" title="9. 列举 Python2和Python3的区别"></a>9. 列举 Python2和Python3的区别</h1><ul><li>Python2<ol><li>print “aa”</li><li>整数之间 / ，只保留整数部分</li><li>不等于 &lt;&gt;</li></ol></li><li>Python3<ol><li>print(“aa”)</li><li>整数之间 / ，保留小数部分</li><li>不等于 !=</li></ol></li></ul><h1 id="10-Python3和Python2中-int-和-long的区别"><a href="#10-Python3和Python2中-int-和-long的区别" class="headerlink" title="10. Python3和Python2中 int 和 long的区别"></a>10. Python3和Python2中 int 和 long的区别</h1><p>在py2中，long是作为长整型的，但在py3中，没有long了，int长度不受限制。</p><h1 id="11-xrange和range的区别"><a href="#11-xrange和range的区别" class="headerlink" title="11. xrange和range的区别"></a>11. xrange和range的区别</h1><ul><li>xrange<br>xrange只在Python2中有，返回的是一个可迭代对象，但并不是迭代器，因为没有实现<strong>next</strong>。<br>在Python3中没有xrange。</li><li>range<br>在Python2中，range返回一个list。<br>在Python3中，range类似于Python2中的xrange，返回的是一个可迭代对象，但也并不是迭代器，因为并没有实现<strong>next</strong>。</li></ul><p><strong>在Python2中xrange比range快，因为range会直接生成一个list，会一开始就开辟一块需要的内存空间，当范围越大这个内存空间越大，而xrange则是惰性计算的。但是为什么开辟一块大的内存空间就会导致慢呢？</strong></p><p><strong>详细关于Py2中的xrange、Python3中的range对象，与迭代器之间的区别，见<a href="https://zhuanlan.zhihu.com/p/34157478](https://zhuanlan.zhihu.com/p/34157478)" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34157478](https://zhuanlan.zhihu.com/p/34157478)</a></strong></p><p><strong>Python3中的range比xrange要快很多，详见</strong><a href="https://zhuanlan.zhihu.com/p/24873916" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24873916</a></p><h1 id="12-文件操作时：xreadlines和readlines的区别"><a href="#12-文件操作时：xreadlines和readlines的区别" class="headerlink" title="12. 文件操作时：xreadlines和readlines的区别"></a>12. 文件操作时：xreadlines和readlines的区别</h1><ul><li>readlines<br>将所有的都读到内存，生成一个list</li><li>xreadlines<br>则返回一个迭代器，但是在py2.3之后就不推荐这么用了，取而代之的是下面这种，这种所需文件内容是自动从buffer中按照需要读取的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">For line in file：</span><br><span class="line">#  Do somenthing</span><br></pre></td></tr></table></figure></li></ul><h1 id="13-字符串、列表、元组、字典每个常用的5个方法"><a href="#13-字符串、列表、元组、字典每个常用的5个方法" class="headerlink" title="13. 字符串、列表、元组、字典每个常用的5个方法"></a>13. 字符串、列表、元组、字典每个常用的5个方法</h1><ul><li><strong>字符串</strong><ol><li>join方法。如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&#39;&#39;.join([&#39;a&#39;, &#39;b&#39;]))</span><br><span class="line">&gt;&gt;&gt; &#39;ab&#39;</span><br></pre></td></tr></table></figure></li><li>split方法。如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&#39;ab,c&#39;.split(&#39;,&#39;))</span><br><span class="line">&gt;&gt;&gt; [&#39;ab&#39;, &#39;c&#39;]</span><br></pre></td></tr></table></figure></li><li>strip方法。如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&#39;abc&#39;.strip(&#39;c&#39;))</span><br><span class="line">&gt;&gt;&gt; ab</span><br></pre></td></tr></table></figure></li><li>lstrip/rstrip方法。去掉左/右端的字符。如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&#39;abc&#39;.rstrip(&#39;c&#39;))</span><br><span class="line">&gt;&gt;&gt; ab</span><br></pre></td></tr></table></figure></li><li>count方法。计算字符串中的某个字符出现的次数。如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&#39;accbc&#39;.count(&#39;c&#39;))</span><br><span class="line">&gt;&gt;&gt; 3</span><br></pre></td></tr></table></figure></li><li>find方法。找到这个字符返回下标，多个时返回第一个；不存在的字符返回-1。如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&#39;abc&#39;.find(&#39;b&#39;))</span><br><span class="line">&gt;&gt;&gt; 1</span><br></pre></td></tr></table></figure></li></ol></li><li><strong>列表</strong><ol><li>切片。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print([&#39;a&#39;, &#39;b&#39;][0:1])</span><br><span class="line">&gt;&gt;&gt; a</span><br></pre></td></tr></table></figure></li><li>append(self, obj)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l &#x3D; [1,2]</span><br><span class="line">l.append(3)</span><br><span class="line">print(l)</span><br><span class="line">&gt;&gt;&gt; [1,2,3]</span><br></pre></td></tr></table></figure></li><li>insert(self, index, obj)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l &#x3D; [1,2]</span><br><span class="line">l.insert(1, 3)</span><br><span class="line">print(l)</span><br><span class="line">&gt;&gt;&gt; [1,3,2]</span><br></pre></td></tr></table></figure></li><li>pop(self, index)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l &#x3D; [1,2]</span><br><span class="line">l.pop(1)</span><br><span class="line">print(l)</span><br><span class="line">&gt;&gt;&gt; [1]</span><br></pre></td></tr></table></figure></li><li>remove(self, obj)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l &#x3D; [1,2]</span><br><span class="line">l.remove(2)</span><br><span class="line">print(l)</span><br><span class="line">&gt;&gt;&gt; [1]</span><br></pre></td></tr></table></figure></li></ol></li><li><strong>字典</strong></li></ul><ol><li>pop(key)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d &#x3D; &#123;&#39;a&#39;:1, &#39;b&#39;:2&#125;</span><br><span class="line">d.pop(&#39;a&#39;)</span><br><span class="line">print(d)</span><br><span class="line">&gt;&gt;&gt; &#123;&#39;b&#39;: 2&#125;</span><br></pre></td></tr></table></figure></li><li>copy() 属于浅拷贝<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d &#x3D; &#123;&#39;a&#39;:1, &#39;b&#39;:2&#125;</span><br><span class="line">copy_d &#x3D; d.copy()</span><br><span class="line">print(copy_d)</span><br><span class="line">&gt;&gt;&gt; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;</span><br></pre></td></tr></table></figure></li><li>len(d)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d &#x3D; &#123;&#39;a&#39;:1, &#39;b&#39;:[1]&#125;</span><br><span class="line">print(len(d))</span><br><span class="line">&gt;&gt;&gt; 2</span><br></pre></td></tr></table></figure></li><li>d.items() 返回由字典中的每一个键值对字典组成的列表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d &#x3D; &#123;&#39;a&#39;:1, &#39;b&#39;:[1]&#125;</span><br><span class="line">print(d.items())</span><br><span class="line">&gt;&gt;&gt; dict_items([(&#39;a&#39;, 1), (&#39;b&#39;, [1])])</span><br></pre></td></tr></table></figure></li><li>del d[‘key’] 删除指定的key对应的键值对<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d &#x3D; &#123;&#39;a&#39;:1, &#39;b&#39;:[1]&#125;</span><br><span class="line">del d[&#39;a&#39;]</span><br><span class="line">print(d)</span><br><span class="line">&gt;&gt;&gt; &#123;&#39;b&#39;: [1]&#125;</span><br></pre></td></tr></table></figure><h1 id="14-lambda表达式格式以及应用场景"><a href="#14-lambda表达式格式以及应用场景" class="headerlink" title="14. lambda表达式格式以及应用场景"></a>14. lambda表达式格式以及应用场景</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lambda x: x+1</span><br></pre></td></tr></table></figure>试用场景，不需要多次使用的地方，例如reduce、map、filter等。</li></ol><h1 id="15-pass的作用"><a href="#15-pass的作用" class="headerlink" title="15. pass的作用"></a>15. pass的作用</h1><p>没有实际意义，可以保持结构完整（当没想好要怎么写的时候就写个pass上去）</p><h1 id="16-arg和-kwarg作用"><a href="#16-arg和-kwarg作用" class="headerlink" title="16. arg和*kwarg作用"></a>16. <em>arg和*</em>kwarg作用</h1><p>可以获取未知个位置参数和关键字参数</p><h1 id="17-is和-的区别"><a href="#17-is和-的区别" class="headerlink" title="17. is和==的区别"></a>17. is和==的区别</h1><p>is比较的是id(存放的地址值就是)    ==比较的是值<br>#18. 简述Python的深浅拷贝以及应用场景<br>浅拷贝就是对引用的拷贝，深拷贝就是对资源的拷贝。<br>如下：b是浅拷贝，c是深拷贝。根据所打印的id值，可以看出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line"></span><br><span class="line">a &#x3D; [1, [2, 3]]</span><br><span class="line">b &#x3D; copy.copy(a)</span><br><span class="line">c &#x3D; copy.deepcopy(a)</span><br><span class="line">a[0] &#x3D; 11</span><br><span class="line">a[1].append(4)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">print(c)</span><br><span class="line">print(id(a[1]), id(b[1]), id(c[1]))</span><br><span class="line">&gt;&gt;&gt; [11, [2, 3, 4]]</span><br><span class="line">&gt;&gt;&gt; [1, [2, 3, 4]]</span><br><span class="line">&gt;&gt;&gt; [1, [2, 3]]</span><br><span class="line">&gt;&gt;&gt; 2127624863432 2127624863432 2127624889032</span><br></pre></td></tr></table></figure><p>Python中，相同的数字或者字符串，都是引用的同一个地址，因此对于数字和字符串来说，无论通过赋值，浅拷贝还是深拷贝，同一个值永远用的是同一个内存地址。</p><p><strong>应用场景:</strong><br>当需要拷贝一份模板资料进行修改，就不能用浅拷贝，这样我用过了别人用的就可能会受到影响</p><h1 id="19-Python垃圾回收机制"><a href="#19-Python垃圾回收机制" class="headerlink" title="19. Python垃圾回收机制"></a>19. Python垃圾回收机制</h1><p>Python中的垃圾回收是以引用计数为主，利用标记清除算法解决引用计数的循环引用问题，通过分代收集提高标记清除的效率。<br><strong>引用计数：</strong><br>在Python中每一个对象的核心就是一个结构体PyObject，它的内部有一个引用计数器（ob_refcnt）。程序在运行的过程中会实时的更新ob_refcnt的值，来反映引用当前对象的名称数量。当某对象的引用计数值为0,那么它的内存就会被立即释放掉。但是引用计数无法解决循环引用的问题，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;[] a.append(a)</span><br></pre></td></tr></table></figure><p><strong>标记–清除算法：</strong><br><a href="https://blog.csdn.net/xiongchengluo1129/java/article/details/80462651" target="_blank" rel="noopener">https://blog.csdn.net/xiongchengluo1129/java/article/details/80462651</a></p><ul><li>标记阶段<br>对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象(root object)，不可达的对象就是要被清除的非活动对象(unreachable)。根对象就是全局变量、调用栈、寄存器。</li><li>清除阶段<br>再次遍历对象，如果发现某个对象没有标记为可达，则将其回收。</li></ul><p><strong>分代回收：</strong><br>在循环引用对象的回收中，整个应用程序会被暂停，为了减少应用程序暂停的时间，Python 通过“分代回收”(Generational Collection)以空间换时间的方法提高垃圾回收效率。</p><p>分代回收是基于这样的一个统计事实，对于程序，存在一定比例的内存块的生存周期比较短；而剩下的内存块，生存周期会比较长，甚至会从程序开始一直持续到程序结束。生存期较短对象的比例通常在 80%～90% 之间，这种思想简单点说就是：对象存在时间越长，越可能不是垃圾，应该越少去收集。这样在执行标记-清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度。</p><p>python gc给对象定义了三种世代(0,1,2),每一个新生对象在generation zero中，如果它在一轮gc扫描中活了下来，那么它将被移至generation one,在那里他将较少的被扫描，如果它又活过了一轮gc,它又将被移至generation two，在那里它被扫描的次数将会更少。</p><p><strong>详见：<a href="https://zhuanlan.zhihu.com/p/83251959" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/83251959</a></strong></p><h1 id="20-Python的可变类型和不可变类型"><a href="#20-Python的可变类型和不可变类型" class="headerlink" title="20. Python的可变类型和不可变类型"></a>20. Python的可变类型和不可变类型</h1><ul><li>可变类型<br>list、set、dict</li><li>不可变类型<br>string、int、float、tuple、frozenset(不可变集合)</li></ul><h1 id="21-求结果"><a href="#21-求结果" class="headerlink" title="21. 求结果"></a>21. 求结果</h1><p>题目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v &#x3D; dict.fromkeys([&#39;k1&#39;,&#39;k2&#39;],[])</span><br><span class="line">v[&#39;k1&#39;].append(666)</span><br><span class="line">print(v)</span><br><span class="line">v[&#39;k1&#39;] &#x3D; 777</span><br><span class="line">print(v)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#39;k1&#39;: [666], &#39;k2&#39;: [666]&#125;</span><br><span class="line">&#123;&#39;k1&#39;: 777, &#39;k2&#39;: [666]&#125;</span><br></pre></td></tr></table></figure><p>原因：<br>因为k1和k2对应的value是同一个list地址，当v[‘k1’].append(666)的时候，由于k1和k2指向的是同一个地址，所以k2对应的value和k1的一样。当v[‘k1’] = 777的时候，k1对应的value的地址变了，但是k2对应的值还是之前的list的地址，所以k1变成了777，k2还是[666]。</p><h1 id="22-求值"><a href="#22-求值" class="headerlink" title="22. 求值"></a>22. 求值</h1><p>题目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def num():</span><br><span class="line">    return [lambda x:i*x for i in range(4)]</span><br><span class="line">print([m(2) for m in num()])</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[6, 6, 6, 6]</span><br></pre></td></tr></table></figure><p>原因：<br>一般可能认为答案应该是[0, 2, 4, 6]，但是由于Python闭包的延迟绑定的特性，答案变成了[6, 6, 6, 6]。<br><strong>Python的延迟绑定其实就是只有当运行到该函数的时候，才会引用外部变量i，不运行的时候，并不是会去找i的值。</strong><br>在当前的题目中，num()只是返回4个lambda对象组成的list，此时lambda函数并没有运行。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;function num.&lt;locals&gt;.&lt;listcomp&gt;.&lt;lambda&gt; at 0x000002A67F4E8488&gt;, &lt;function num.&lt;locals&gt;.&lt;listcomp&gt;.&lt;lambda&gt; at 0x000002A67F4E8400&gt;, &lt;function num.&lt;locals&gt;.&lt;listcomp&gt;.&lt;lambda&gt; at 0x000002A67F4E8510&gt;, &lt;function num.&lt;locals&gt;.&lt;listcomp&gt;.&lt;lambda&gt; at 0x000002A67F4E8598&gt;]</span><br></pre></td></tr></table></figure><p>当运行到[m(2) for m in num()]的时候，才会真正运行到lambda函数。此时，i已经是3了，所以实际上得到的结果是[6, 6, 6, 6]</p><h1 id="23-列举常见的内置函数"><a href="#23-列举常见的内置函数" class="headerlink" title="23. 列举常见的内置函数"></a>23. 列举常见的内置函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len、bin、hex、oct、dir、max、min、type、sorted、isinstance、issubclass</span><br></pre></td></tr></table></figure><h1 id="24-filter、map、reduce的作用"><a href="#24-filter、map、reduce的作用" class="headerlink" title="24. filter、map、reduce的作用"></a>24. filter、map、reduce的作用</h1><ul><li>filter(function, iterable)<br>根据function，将iterable中的不符合条件的过滤掉。filter返回一个迭代器。<br>例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">l &#x3D; [1,2]</span><br><span class="line">l &#x3D; filter(lambda x: True if x&#x3D;&#x3D;1 else False, l)</span><br><span class="line"></span><br><span class="line">print(l)</span><br><span class="line">print(list(l))</span><br><span class="line">&gt;&gt;&gt; &lt;filter object at 0x0000020ADB68B2B0&gt;</span><br><span class="line">&gt;&gt;&gt; [1]</span><br></pre></td></tr></table></figure></li><li>map(func, <em>iterables)<br>将func作用域</em>iterables中的每个序列的参数，返回一个map对象，该map对象也是一个迭代器。<br>例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l &#x3D; map(lambda x,y :x+y, [1,2], [2,3])</span><br><span class="line">print(list(l))</span><br><span class="line">&gt;&gt;&gt; [3, 5]</span><br></pre></td></tr></table></figure></li><li>reduce(function, sequence, initial=None)<br>function是一个接受2个参数的函数。将function累计地作用到sequence中的每个元素上，从左到右，将这个sequence的所有值计算成一个值。<br>例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]))</span><br><span class="line"># ((((1+2)+3)+4)+5)</span><br><span class="line">&gt;&gt;&gt; 15</span><br></pre></td></tr></table></figure><h1 id="25-一行代码实现9-9乘法表"><a href="#25-一行代码实现9-9乘法表" class="headerlink" title="25. 一行代码实现9*9乘法表"></a>25. 一行代码实现9*9乘法表</h1></li><li>这里用了f-string<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&#39;\n&#39;.join([&#39; &#39;.join([f&#39;&#123;y&#125; * &#123;x&#125; &#x3D; &#123;x * y&#125;&#39; for y in range(1, x+1)]) for x in range(1,10)]))</span><br></pre></td></tr></table></figure></li></ul><h1 id="26-至少列举8个常用模块都有那些"><a href="#26-至少列举8个常用模块都有那些" class="headerlink" title="26. 至少列举8个常用模块都有那些"></a>26. 至少列举8个常用模块都有那些</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os sys json time datetime random requests copy re...</span><br></pre></td></tr></table></figure><h1 id="27-re的match和search区别"><a href="#27-re的match和search区别" class="headerlink" title="27. re的match和search区别"></a>27. re的match和search区别</h1><ul><li>match<br>必须字符串的开头就匹配上。</li><li>search<br>不需要字符串的开头就匹配上。匹配到结果后就返回</li></ul><h1 id="28-什么是正则的贪婪匹配"><a href="#28-什么是正则的贪婪匹配" class="headerlink" title="28. 什么是正则的贪婪匹配"></a>28. 什么是正则的贪婪匹配</h1><p>贪婪模式在整个表达式匹配成功的前提下，尽可能多的匹配，而非贪婪模式在整个表达式匹配成功的前提下，尽可能少的匹配。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">s &#x3D; &#39;abbcbbc&#39;</span><br><span class="line">res1 &#x3D; re.search(r&#39;a.*c&#39;, s)</span><br><span class="line">res2 &#x3D; re.search(r&#39;a.*?c&#39;, s)</span><br><span class="line">print(res1[0])</span><br><span class="line">print(res2[0])</span><br><span class="line">&gt;&gt;&gt; abbcbbc</span><br><span class="line">&gt;&gt;&gt; abbc</span><br></pre></td></tr></table></figure><h1 id="29-求结果"><a href="#29-求结果" class="headerlink" title="29. 求结果"></a>29. 求结果</h1><ul><li>1 or 2<br>1</li><li>1 and 2<br>1</li><li>1 &lt; (2==2)<br>False<br>因为(2==2)先执行</li><li>1 &lt; 2 == 2<br>True<br>因为Python可以链式比较，这里这句话是相当于(1&lt;2) and (2==2)</li></ul><h1 id="30-def-func-a-b-这种写法有什么坑"><a href="#30-def-func-a-b-这种写法有什么坑" class="headerlink" title="30. def func(a,b=[]) 这种写法有什么坑"></a>30. def func(a,b=[]) 这种写法有什么坑</h1><p>假如在调用的时候不给b传值，用默认的list，会造成所有默认的都是用同一个list<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def func(a, b&#x3D;[]):</span><br><span class="line">    b.append(a)</span><br><span class="line">    print(b)</span><br><span class="line">func(1)</span><br><span class="line">func(1)</span><br><span class="line">&gt;&gt;&gt; [1]</span><br><span class="line">&gt;&gt;&gt; [1, 1]</span><br></pre></td></tr></table></figure><h1 id="31-如何实现-“1-2-3”-变成-‘1’-’2’-’3’"><a href="#31-如何实现-“1-2-3”-变成-‘1’-’2’-’3’" class="headerlink" title="31. 如何实现 “1,2,3” 变成 [‘1’,’2’,’3’]"></a>31. 如何实现 “1,2,3” 变成 [‘1’,’2’,’3’]</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;1,2,3&quot;.split(&#39;,&#39;)</span><br></pre></td></tr></table></figure><h1 id="32-如何实现-‘1’-’2’-’3’-变成-1-2-3"><a href="#32-如何实现-‘1’-’2’-’3’-变成-1-2-3" class="headerlink" title="32. 如何实现[‘1’,’2’,’3’]变成[1,2,3]"></a>32. 如何实现[‘1’,’2’,’3’]变成[1,2,3]</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l &#x3D; [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;]</span><br><span class="line">lis &#x3D; list(map(lambda x:int(x), l))</span><br></pre></td></tr></table></figure><h1 id="33-比较：-a-1-2-3-和-b-1-2-3-以及-b-1-2-3-的区别"><a href="#33-比较：-a-1-2-3-和-b-1-2-3-以及-b-1-2-3-的区别" class="headerlink" title="33. 比较： a = [1,2,3] 和 b = [(1),(2),(3) ] 以及 b = [(1,),(2,),(3,) ] 的区别"></a>33. 比较： a = [1,2,3] 和 b = [(1),(2),(3) ] 以及 b = [(1,),(2,),(3,) ] 的区别</h1><p>a是列表<br>b = [(1),(2),(3)] 虽然列表的每个元素加上了括号，但是当括号内只有一个元素并且没有逗号时，其数据类型是元素本身的数据类型<br>b2中的元素是tuple[元组]</p><h1 id="34-如何用一行代码生成-1-4-9-16-25-36-49-64-81-100"><a href="#34-如何用一行代码生成-1-4-9-16-25-36-49-64-81-100" class="headerlink" title="34. 如何用一行代码生成[1,4,9,16,25,36,49,64,81,100]"></a>34. 如何用一行代码生成[1,4,9,16,25,36,49,64,81,100]</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">li &#x3D; [x*x for x in range(1,11)]</span><br></pre></td></tr></table></figure><h1 id="35-一行代码实现删除列表中重复的值"><a href="#35-一行代码实现删除列表中重复的值" class="headerlink" title="35. 一行代码实现删除列表中重复的值"></a>35. 一行代码实现删除列表中重复的值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list0 &#x3D; [&#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;a&#39;]</span><br><span class="line">print(list(set(list0)))</span><br></pre></td></tr></table></figure><h1 id="36-如何在函数中设置一个全局变量"><a href="#36-如何在函数中设置一个全局变量" class="headerlink" title="36. 如何在函数中设置一个全局变量"></a>36. 如何在函数中设置一个全局变量</h1><ul><li>step1. 在全局作用域申明一个变量</li><li>step2. 在函数中，通过global关键字将该变量申明为全局变量。如果不申明，会被当成函数内的局部变量而报错。<br>例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 1</span><br><span class="line"></span><br><span class="line">def func():</span><br><span class="line">    global a</span><br><span class="line">    a +&#x3D; 1</span><br><span class="line">func()</span><br><span class="line">print(a)</span><br><span class="line">&gt;&gt;&gt; 2</span><br></pre></td></tr></table></figure><h1 id="37-logging模块的作用，以及应用场景"><a href="#37-logging模块的作用，以及应用场景" class="headerlink" title="37. logging模块的作用，以及应用场景"></a>37. logging模块的作用，以及应用场景</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logging.debug(msg, *args, **kwargs)</span><br><span class="line">logging.info(msg, *args, **kwargs)</span><br><span class="line">logging.warning(msg, *args, **kwargs)</span><br><span class="line">logging.error(msg, *args, **kwargs)</span><br><span class="line">logging.critical(msg, *args, **kwargs)</span><br></pre></td></tr></table></figure>作用：根据不同需要输出不同等级、详细程度不同的信息。<br>应用场景：网站运维，程序的实时监控。</li></ul><h1 id="38-请用代码简答stack"><a href="#38-请用代码简答stack" class="headerlink" title="38. 请用代码简答stack"></a>38. 请用代码简答stack</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Stack():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._stack &#x3D; []</span><br><span class="line"></span><br><span class="line">    def push(self, v):</span><br><span class="line">        self._stack.append(v)</span><br><span class="line"></span><br><span class="line">    def pop(self):</span><br><span class="line">        try:</span><br><span class="line">            return self._stack.pop()</span><br><span class="line">        except IndexError:</span><br><span class="line">            raise ValueError(&quot;empty stack&quot;)</span><br><span class="line"></span><br><span class="line">    def is_empty(self):</span><br><span class="line">        return bool(self._stack)</span><br><span class="line"></span><br><span class="line">    def watch(self):</span><br><span class="line">        return self._stack</span><br></pre></td></tr></table></figure><h1 id="39-常用字符串格式化哪几种"><a href="#39-常用字符串格式化哪几种" class="headerlink" title="39. 常用字符串格式化哪几种"></a>39. 常用字符串格式化哪几种</h1><ul><li><p>%s %d</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D; &#39;f&#39;</span><br><span class="line">print(&#39;%s&#39; % a)</span><br><span class="line">&gt;&gt;&gt; f</span><br></pre></td></tr></table></figure></li><li><p>f-string</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 1</span><br><span class="line">print(f&#39;&#123;a&#125;+2&#x3D;&#123;a+2&#125;&#39;)</span><br><span class="line">&gt;&gt;&gt; 1+2&#x3D;3</span><br></pre></td></tr></table></figure></li><li><p>format</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&#39;&#123;name&#125; am handsome boy.&#39;.format(name&#x3D;&quot;I&quot;))</span><br><span class="line">&gt;&gt;&gt; I am handsome boy.</span><br></pre></td></tr></table></figure><h1 id="40-生成器、迭代器、可迭代对象、应用场景"><a href="#40-生成器、迭代器、可迭代对象、应用场景" class="headerlink" title="40. 生成器、迭代器、可迭代对象、应用场景"></a>40. 生成器、迭代器、可迭代对象、应用场景</h1></li><li><p>生成器<br>可以理解为是一种一边循环一边计算的数据类型。<br>两种方式：</p><ol><li>生成器表达式。例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(i for i in range(10))</span><br><span class="line">&gt;&gt;&gt; &lt;generator object &lt;genexpr&gt; at 0x000001F6BA656A40&gt;</span><br></pre></td></tr></table></figure></li><li>函数中加yield。例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def func():</span><br><span class="line">    for i in range(10):</span><br><span class="line">        yield i</span><br><span class="line"></span><br><span class="line">print(func())</span><br><span class="line">&gt;&gt;&gt; &lt;generator object func at 0x00000251C8716A40&gt;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>迭代器<br>任何实现了<strong>iter</strong>和<strong>next</strong>的对象就是迭代器。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from collections import Iterator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class IterA:</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">print(isinstance(IterA(), Iterator))</span><br><span class="line">&gt;&gt;&gt; True</span><br></pre></td></tr></table></figure></li><li><p>可迭代对象<br>对象内部实现了<strong>iter</strong>()方法，并调用这个方法可返回一个迭代器对象。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from collections import Iterable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class IterA:</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">print(isinstance(IterA(), Iterable))</span><br><span class="line">&gt;&gt;&gt; True</span><br></pre></td></tr></table></figure><p>应用场景：优化代码，节省内存</p><h1 id="41-用Python实现一个二分查找的函数"><a href="#41-用Python实现一个二分查找的函数" class="headerlink" title="41. 用Python实现一个二分查找的函数"></a>41. 用Python实现一个二分查找的函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def two_search(list, value):</span><br><span class="line">    lindex &#x3D; 0</span><br><span class="line">    rindex &#x3D; len(list) - 1</span><br><span class="line">    cindex &#x3D; (lindex + rindex) &#x2F;&#x2F; 2  # &#x2F; 在py3中是包括了小数部分的</span><br><span class="line">    res &#x3D; -1</span><br><span class="line">    # 二分法唯一的一个问题是，当所求的数是最右边的时候，按照cindex &#x3D; (lindex + rindex) &#x2F; 2的方式，当cindex &#x3D; lindex的时候会死循环</span><br><span class="line">    if list[-1] &#x3D;&#x3D; value:</span><br><span class="line">        res &#x3D; rindex</span><br><span class="line">    else:</span><br><span class="line">        while lindex !&#x3D; cindex or cindex &#x3D;&#x3D; 0:</span><br><span class="line">            if value &#x3D;&#x3D; list[cindex]:</span><br><span class="line">                res &#x3D; cindex</span><br><span class="line">                break</span><br><span class="line">            elif value &gt; list[cindex]:</span><br><span class="line">                lindex &#x3D; cindex</span><br><span class="line">                cindex &#x3D; (lindex + rindex) &#x2F;&#x2F; 2</span><br><span class="line">            else:</span><br><span class="line">                rindex &#x3D; cindex</span><br><span class="line">                cindex &#x3D; (lindex + rindex) &#x2F;&#x2F; 2</span><br><span class="line">    return res</span><br><span class="line"></span><br><span class="line">l &#x3D; [1, 2, 3, 4, 5, 6, 9, 19, 40]</span><br><span class="line">print(two_search(l, 5))</span><br><span class="line">&gt;&gt;&gt;  4</span><br></pre></td></tr></table></figure><h1 id="42-谈谈你对闭包的理解"><a href="#42-谈谈你对闭包的理解" class="headerlink" title="42. 谈谈你对闭包的理解"></a>42. 谈谈你对闭包的理解</h1></li><li><p>闭包可以使得我们能获取到外部函数的参数和局部变量。</p></li><li><p>闭包的使用，可以减少全局变量的污染，因为当使用全局变量的时候，全局变量可以被其他的所有的函数修改。</p></li><li><p>闭包在装饰器上也有应用，把被修饰的函数作为参数保存了下来。</p></li><li><p>闭包的缺点：是常驻内存的，会对增大内存的使用量。</p></li></ul><h1 id="43-os和sys模块的作用"><a href="#43-os和sys模块的作用" class="headerlink" title="43. os和sys模块的作用"></a>43. os和sys模块的作用</h1><ul><li>os<br>os模块负责程序与操作系统的交互，提供了访问操作系统底层的接口;<br>os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径<br>os.chdir(“dirname”)  改变当前脚本工作目录；相当于shell下cd</li><li>sys<br>sys模块负责程序与python解释器的交互，提供了一系列的函数和变量，用于操控python的运行时环境。<br>Sys.exit(n)退出程序<br>Sys.version返回python解释器版本</li></ul><h1 id="44-如何生成一个随机数"><a href="#44-如何生成一个随机数" class="headerlink" title="44. 如何生成一个随机数"></a>44. 如何生成一个随机数</h1><ul><li>Random.random() 随机生成一个浮点数，但是不能指定范围</li><li>Random.uniform(start,stop)随机生成一个浮点数，可以指定范围</li><li>Random.randomint(start, stop)生成一个整形的随机数</li></ul><h1 id="45-如何使用python删除一个文件"><a href="#45-如何使用python删除一个文件" class="headerlink" title="45. 如何使用python删除一个文件"></a>45. 如何使用python删除一个文件</h1><p>Os.remove()</p><h1 id="46-谈谈你对面向对象的理解"><a href="#46-谈谈你对面向对象的理解" class="headerlink" title="46. 谈谈你对面向对象的理解"></a>46. 谈谈你对面向对象的理解</h1><ul><li>面向对象是一种编程思想。思想是万物皆对象。所有物体可以归类，每个实际的东西就是对应的那个类别的实例。</li><li>面向对象的编程是以对象为中心，以消息为驱动的，就是 程序=对象+消息。</li><li>面向对象有三大特性：</li></ul><p><strong>封装</strong>：将具体的对象封装成抽象的类，对外封装属性，但是提供使用接口，目的是降低复杂      度，加大安全性。<br><strong>继承</strong>：儿子继承爸爸的方法和属性，减少冗余代码。<br><strong>多态</strong>：通过多态可以实现用一个函数名调用不同内容的函数。分为静态多态性和动态多态性<br>      静态多态性：静态就是在执行之前python解释器已经知道要调用哪个函数了，多态就是我们不用管到底是操作的对象是什么类型的，多种形态都是可以进行这个运算的。<br>      动态多态性：编译时无法立即确定其处理方式 , 只有在执行时才确定处理方式 , 注意一定要同名</p><h1 id="47-Python面向对象中的继承有什么特点"><a href="#47-Python面向对象中的继承有什么特点" class="headerlink" title="47. Python面向对象中的继承有什么特点"></a>47. Python面向对象中的继承有什么特点</h1><ol><li>在新式类中，方法的调用按照C3算法：拓扑排序+最左优先原则。</li></ol><h1 id="48-面向对象中super的作用"><a href="#48-面向对象中super的作用" class="headerlink" title="48. 面向对象中super的作用"></a>48. 面向对象中super的作用</h1><p>调用父类的方法</p><h1 id="49-是否使用过functools中的函数？其作用是什么"><a href="#49-是否使用过functools中的函数？其作用是什么" class="headerlink" title="49. 是否使用过functools中的函数？其作用是什么"></a>49. 是否使用过functools中的函数？其作用是什么</h1><p>functools主要是一些python高阶函数相关的函数<br>reduce函数<br>作用是用传入的函数对序列的每个值递进式地计算，最终计算出一个值。</p><h1 id="50-列举面向对象中带双下划线的特殊方法。"><a href="#50-列举面向对象中带双下划线的特殊方法。" class="headerlink" title="50. 列举面向对象中带双下划线的特殊方法。"></a>50. 列举面向对象中带双下划线的特殊方法。</h1><ul><li><strong>new</strong>：实例化对象的时候被调用</li><li><strong>dict</strong>：获取类或对象中的所有成员</li><li><strong>getitem</strong>、<strong>setitem</strong>、<strong>delitem</strong>：通过 [] 被调用</li><li><strong>getattr</strong>、<strong>setattr</strong>、<strong>delattr</strong>：通过 . 被调用</li><li><strong>call</strong>：为了将一个实例当做函数一样调用，例如a是A的实例，让a()可以直接执行</li><li><strong>str</strong>：打印实例的时候调用的，一般是return一个字符串。例如a=A(),print(a)就会执行<h1 id="51-如何判断是函数还是方法"><a href="#51-如何判断是函数还是方法" class="headerlink" title="51. 如何判断是函数还是方法"></a>51. 如何判断是函数还是方法</h1>在类中定义的函数就是方法<h1 id="52-静态方法和类方法区别"><a href="#52-静态方法和类方法区别" class="headerlink" title="52. 静态方法和类方法区别"></a>52. 静态方法和类方法区别</h1></li><li>静态方法：当类去调用方法的时候不用实例化实例就可以调用；参数设置上不需要传递表示实例的self参数；依赖于装饰器@staticmethod</li><li>类方法：当类去调用的时候不用实例化；参数设置上，第一个表示实例的self参数被表示类的cls取代了；依赖于装饰器@classmethod<br>这里的self和cls都只是大家默认的而已，改成任何别的字母都是可以的<h1 id="53-1、2、3、4、5-能组成多少个互不相同且无重复的三位数"><a href="#53-1、2、3、4、5-能组成多少个互不相同且无重复的三位数" class="headerlink" title="53. 1、2、3、4、5 能组成多少个互不相同且无重复的三位数"></a>53. 1、2、3、4、5 能组成多少个互不相同且无重复的三位数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">count &#x3D; 0</span><br><span class="line">for i in range(1, 6):</span><br><span class="line">    for j in range(1, 6):</span><br><span class="line">        for k in range(1, 6):</span><br><span class="line">            if i !&#x3D; j and j !&#x3D; k and i !&#x3D; k:</span><br><span class="line">                count +&#x3D; 1</span><br><span class="line">print(count)</span><br><span class="line">&gt;&gt;&gt; 60</span><br></pre></td></tr></table></figure></li></ul><h1 id="54-什么是反射？以及应用场景"><a href="#54-什么是反射？以及应用场景" class="headerlink" title="54. 什么是反射？以及应用场景"></a>54. 什么是反射？以及应用场景</h1><p>它的核心本质其实就是利用字符串的形式去对象（模块）中操作（查找/获取/删除/添加）成员，一种基于字符串的事件驱动。<br>应用场景：当a写程序程序写到一半没写完，但是b写的会用到a中的函数或者类，b就可以通过反射机制写完自己的程序。</p><h1 id="55-metaclass作用，以及应用场景"><a href="#55-metaclass作用，以及应用场景" class="headerlink" title="55. metaclass作用，以及应用场景"></a>55. metaclass作用，以及应用场景</h1><p><strong>作用：</strong><br>metaclass直译为元类<br>metaclasss可以作为类声明时候的一个参数，可以传入我们自定义的元类<br>元类相当于是类的类，Python中内置的元类是type<br>所以所有自定义的元类都需要继承自type<br><strong>应用场景</strong>：<br>可以控制类的调用，比方说当类中没有注释（<strong>doc</strong>）的时候，抛出异常之类，当类的名称命名规则不对的时候，抛出异常之类</p><h1 id="56-单例模式"><a href="#56-单例模式" class="headerlink" title="56. 单例模式"></a>56. 单例模式</h1><p>是一种常用的软件设计模式，该模式的主要目的是确保某一个类只有一个实例存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Singleton:</span><br><span class="line">    _instance &#x3D; None</span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        if not cls._instance:</span><br><span class="line">            cls._instance &#x3D; super().__new__(cls, *args, **kwargs)</span><br><span class="line">        return cls._instance</span><br></pre></td></tr></table></figure><h1 id="57-装饰器"><a href="#57-装饰器" class="headerlink" title="57. 装饰器"></a>57. 装饰器</h1><p><strong>特点：</strong></p><ol><li>不改变原函数的源代码</li><li>不改变原函数的调用</li></ol><p><strong>实现：</strong><br>利用闭包、高阶函数、语法糖实现。</p><p><strong>例如：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def wrapper(f):</span><br><span class="line">    def inner(*args, **kwargs):</span><br><span class="line">        print(&quot;before&quot;)</span><br><span class="line">        f()</span><br><span class="line">        print(&quot;after&quot;)</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@wrapper</span><br><span class="line">def func():</span><br><span class="line">    print(1)</span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line">&gt;&gt;&gt; before</span><br><span class="line">&gt;&gt;&gt; 1</span><br><span class="line">&gt;&gt;&gt; after</span><br></pre></td></tr></table></figure><p><strong>带参数的装饰器：</strong><br>在wrapper外面再套一层函数来接受参数，并将wrapper方法返回。在语法糖调用的时候加上括号，并填入参数，就相当于在执行到@语法糖对应的语句之前先执行了outer(a=”…”)函数，而outer函数返回wrapper函数，这样在把参数通过outer(a=”…”)函数传递进去之后，又变成了@wrapper的形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def outer(a):</span><br><span class="line">    def wrapper(f):</span><br><span class="line">        def inner(*args, **kwargs):</span><br><span class="line">            print(&quot;before&quot;)</span><br><span class="line">            print(&quot;print outer&#39;s args: &quot;, a)</span><br><span class="line">            f()</span><br><span class="line">            print(&quot;after&quot;)</span><br><span class="line"></span><br><span class="line">        return inner</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@outer(a&#x3D;&quot;outer&quot;)</span><br><span class="line">def func():</span><br><span class="line">    print(1)</span><br></pre></td></tr></table></figure><p>应用场景：<br>性能测试、权限判断等  </p><h1 id="58-什么是面向对象的mro"><a href="#58-什么是面向对象的mro" class="headerlink" title="58. 什么是面向对象的mro"></a>58. 什么是面向对象的mro</h1><p>mro(method resolution order)方法解析列表<br>代表了新式类继承的顺序，具体是用了一个c3算法，就是拓扑排序+最左优先原则</p><h1 id="59-isinstance作用以及应用场景"><a href="#59-isinstance作用以及应用场景" class="headerlink" title="59. isinstance作用以及应用场景"></a>59. isinstance作用以及应用场景</h1><p>isinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。</p><p>isinstance() 与 type() 区别：</p><p>type() 不会认为子类是一种父类类型，不考虑继承关系。</p><p>isinstance() 会认为子类是一种父类类型，考虑继承关系。</p><p>如果要判断两个类型是否相同推荐使用 isinstance()。</p><h1 id="60-json序列化时，可以处理的数据类型有哪些，如何定制支持datetime类型"><a href="#60-json序列化时，可以处理的数据类型有哪些，如何定制支持datetime类型" class="headerlink" title="60 . json序列化时，可以处理的数据类型有哪些，如何定制支持datetime类型"></a>60 . json序列化时，可以处理的数据类型有哪些，如何定制支持datetime类型</h1><p>可以处理的数据类型：<br>string、int、list、tuple、dict、bool、null<br>支持datetime：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line">ret &#x3D; datetime.datetime.now()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class CJsonEncoder(json.JSONEncoder):</span><br><span class="line">    def default(self, obj):</span><br><span class="line"></span><br><span class="line">        if isinstance(obj, datetime.date):</span><br><span class="line">            return obj.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)</span><br><span class="line">        else:</span><br><span class="line">            return json.JSONEncoder.default(self, obj)</span><br><span class="line"></span><br><span class="line">print(json.dumps(ret, cls&#x3D;CJsonEncoder))</span><br></pre></td></tr></table></figure><h1 id="61-json序列化时，默认遇到中文会转换成unicode，如果想要保留中文怎么办"><a href="#61-json序列化时，默认遇到中文会转换成unicode，如果想要保留中文怎么办" class="headerlink" title="61. json序列化时，默认遇到中文会转换成unicode，如果想要保留中文怎么办"></a>61. json序列化时，默认遇到中文会转换成unicode，如果想要保留中文怎么办</h1><p>在序列化是将json.dumps中的默认参数ensure_ascii改为False就可以保留中文了<br>json.dumps(obj,ensure_ascii=False)</p><h1 id="62-什么是断言，应用场景"><a href="#62-什么是断言，应用场景" class="headerlink" title="62. 什么是断言，应用场景"></a>62. 什么是断言，应用场景</h1><p><strong>什么是断言：</strong><br>断言是编程术语，表示为一些布尔表达式。如果它为真，就不做任何事。如果它为假，则会抛出AssertError并且包含错误信息。<br><strong>应用场景：</strong><br>在执行某些步骤前，先检查参数是否正确。</p><h1 id="63-有用过with-statement吗，它的好处是什么"><a href="#63-有用过with-statement吗，它的好处是什么" class="headerlink" title="63. 有用过with statement吗，它的好处是什么"></a>63. 有用过with statement吗，它的好处是什么</h1><p>有用过，用来打开文件的时候使用。<br><strong>好处：</strong></p><ol><li>解决异常退出时资源释放的问题； （不用try catch）</li><li>解决用户忘记调用close方法而产生的资源泄漏问题；（不用手动关闭）</li></ol><h1 id="64-使用代码实现查看列举目录下的所有文件"><a href="#64-使用代码实现查看列举目录下的所有文件" class="headerlink" title="64. 使用代码实现查看列举目录下的所有文件"></a>64. 使用代码实现查看列举目录下的所有文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">sys.setrecursionlimit(100000)</span><br><span class="line"></span><br><span class="line">def pridir(path&#x3D;os.getcwd()):</span><br><span class="line">    list &#x3D; os.listdir(path)</span><br><span class="line">    if len(list) !&#x3D; 0:</span><br><span class="line">        for i in list:</span><br><span class="line">            newpath &#x3D; path+os.sep+i</span><br><span class="line">            if os.path.isdir(newpath):</span><br><span class="line">                pridir(newpath)</span><br><span class="line">            elif os.path.isfile(newpath):</span><br><span class="line">                print(i)</span><br><span class="line"></span><br><span class="line">pridir(&quot;D:\\rm&quot;)</span><br></pre></td></tr></table></figure><h1 id="65-简述-yield和yield-from关键字"><a href="#65-简述-yield和yield-from关键字" class="headerlink" title="65. 简述 yield和yield from关键字"></a>65. 简述 yield和yield from关键字</h1><ul><li>yield:</li></ul><p>1.向外抛出value<br>2.暂停等待外部send/next()恢复<br>3.将send进来的值赋值</p><ul><li>yield from<br>yield from iterable本质上等于for item in iterable: yield item的缩写版 </li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def fun_inner():</span><br><span class="line">    i &#x3D; 0</span><br><span class="line">    while True:</span><br><span class="line">        i &#x3D; yield i</span><br><span class="line"></span><br><span class="line"># outer的作用就是将传递进来的参数传给inner，并且把inner返回的传给调用outer的地方</span><br><span class="line">def fun_outer():</span><br><span class="line">    inner &#x3D; fun_inner()</span><br><span class="line">    inner.send(None)</span><br><span class="line">    while True:</span><br><span class="line">        a &#x3D; inner.send(1)</span><br><span class="line">        yield a</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    outer &#x3D; fun_outer()</span><br><span class="line">    outer.send(None)</span><br><span class="line">    for i in range(5):</span><br><span class="line">        print(outer.send(i))</span><br></pre></td></tr></table></figure><p>用yield from修改后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def fun_inner():</span><br><span class="line">    i &#x3D; 0</span><br><span class="line">    while True:</span><br><span class="line">        i &#x3D; yield i</span><br><span class="line"></span><br><span class="line">def fun_outer():</span><br><span class="line">    yield from fun_inner()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    outer &#x3D; fun_outer()</span><br><span class="line">    outer.send(None)</span><br><span class="line">    for i in range(5):</span><br><span class="line">        print(outer.send(i))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;申明：这里整理的面试题题目主要来源于网络搜集，答案根据自己实践整理修改。&lt;/p&gt;
&lt;h1 id=&quot;1-简述解释型语言和编译型语言区别&quot;&gt;&lt;a href=&quot;#1-简述解释型语言和编译型语言区别&quot; class=&quot;headerlink&quot; title=&quot;1. 简述解释型语言和编译型
      
    
    </summary>
    
    
      <category term="面试" scheme="https://github.com/Enochxyn/blog.github.io.git/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="https://github.com/Enochxyn/blog.github.io.git/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
